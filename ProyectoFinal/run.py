# -*- coding: utf-8 -*-
"""ProyectoFinalGiovannyEncinia.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hUJf94Nx7vn1EO32dj3baHKVVK3aRV0U
"""

# Giovanny Encinia
# 12/26/2021

import numpy as np
import matplotlib.pyplot as plt


def lorenz(t, Y):
    """

    Es un sistema de ecuaciones parciales acoplado, es un sistema caotico
    que trata de modelar de manera sobresimplificada la atmosfera terrestre

    Parameters
    ===========
    t: es el tiempo transcurrido
    x: variable que representa movimiento en el eje x
    y: variable que representa movimiento en el eje y
    z: variable que representa movimiento en el eje z

    Return
    =======
    numpy array: [float, float, float], se guardan los movimientos en
    el espacio
    """

    # x' = 10(y - x)
    fx = 10. * (Y[1] - Y[0])
    # y' = x(28 - z) - y
    fy = Y[0] * (28 - Y[2]) - Y[1]
    # z' = xy - 8z/3
    fz = Y[0] * Y[1] - 8. * Y[2] / 3.

    return np.array([fx, fy, fz]) #se usa numpy para aprovechar la vectorizacion


def rossler(t, Y):
    """

    Es un sistema de ecuaciones parciales acoplado, el resultado forma una
    concha de mar

    Parameters
    ===========
    t: es el tiempo transcurrido
    x: variable que representa movimiento en el eje x
    y: variable que representa movimiento en el eje y
    z: variable que representa movimiento en el eje z

    Return
    =======
    numpy array: [float, float, float], se guardan los movimientos en
    el espacio
    """

    #x == Y[0], y == Y[1], z == Y[2]
    # x' = -(y + x)
    fx = -(Y[1] + Y[2])
    # y' = x + 0.2y
    fy = Y[0] + 0.2 * Y[1]
    # z' = 0.2 + z(x - 5.7)
    fz = 0.2 + Y[2] * (Y[0] - 5.7)

    return np.array([fx, fy, fz]) #se usa numpy para aprovechar la vectorizacion


def zhou(t, Y):
    """
    Es un sistema de ecuaciones parciales acoplado que
    puede provocar un sistema caotico con forma de mariposa parecido al atractor
    de Lorenz

    Parameters
    ===========
    t: es el tiempo transcurrido
    x: variable que representa movimiento en el eje x
    y: variable que representa movimiento en el eje y
    z: variable que representa movimiento en el eje z

    Return
    =======
    numpy array: [float, float, float], se guardan los movimientos en
    el espacio
    """

    # x' = 10(y - x)
    fx = 10. * (Y[1] - Y[0])
    # y' = x(16 - z)
    fy = Y[0] * (16. - Y[2])
    # z' = xy - z
    fz = Y[0] * Y[1] - Y[2]

    return np.array([fx, fy, fz]) #se usa numpy para aprovechar la vectorizacion


def rugen_kutta4(t, Y, h, function):
    """

    Se utiliza el metodo de runge kutta de cuarto orden

    Parameters
    ==========
    t: es el tiempo, variable x, parametro
    y: usualmente es la variable y de la ecuacion, pero es ondependiente 
    del simbolo
    h: es el aumento que hay en la variable t

    Return
    =======
    list: regresa una lista que contiene tuplas que contienen los (t, y)
    """

    #listas donde se almacenaran los datos del atractor, espacio, tiempo
    x = []
    y = []
    z = []
    T = []
    
    #Simula los primeros 20 movimientos
    for _ in range(20000):
        k1 = function(t, Y)
        k2 = function(t + h / 2., Y + h * k1 / 2.)
        k3 = function(t + h / 2., Y + h * k2 / 2.)
        k4 = function(t + h, Y + h * k3)
        Y += h * (k1 + 2. * k2 + 2. * k3 + k4) / 6. #promedio ponderado
        t += h
        T.append(t)
        x.append(Y[0])
        y.append(Y[1])
        z.append(Y[2])

    return T, x, y, z


def plot_atractor_3d(name, x, y, z):
    """

    Se plotea el grafico del atracor en 3d

    Parameters
    ===========
    name: es el nombre que aparece sobre la grafica y 
    el nombre con el que se queda guardado el archivo png
    x: vector que contiene las coordenadas en x
    y: vector que contiene las coordenadas en x
    z: vector que contiene las coordenadas en x
    """
    # resolucion de la imagen
    fig = plt.figure(dpi=150)
    # tipo de proyeccion, en 3d
    ax = fig.gca(projection='3d')
    ax.plot(x, y, z, lw=0.5)
    ax.set_xlabel("X Axis")
    ax.set_ylabel("Y Axis")
    ax.set_zlabel("Z Axis")
    ax.set_title(name)
    
    # guarda la imagen
    plt.savefig(name + '.png')
    plt.show()

def plot_atractor_2d(name, eje1, eje2, a, b):
    """
    Se imprime el atractor en dos dimensiones

    Parameters
    ===========
    name: es el nombre que contrndra el archivo, y se pide que se agregue 
    el nombre del atractor
    eje1: es el eje que funjira como variable dependiente
    eje2: variable independiente
    a: es el vector que contiene datos que van en eje1
    b: es el vector que contiene datos que van en eje2
    """
    
    # resolucion de la imagen
    fig = plt.figure(dpi=150)
    plt.plot(a, b, lw=0.5, c="purple")
    plt.xlabel(eje1 + " Axis")
    plt.ylabel(eje2 + " Axis")
    plt.title(name)
    # guarda la imagen
    plt.savefig(name + eje1 + eje2 + '.png')
    plt.show()


def run():
    """
    Funcion que corre y genera las graficas de los diferentes atractores
    """

    funciones = [zhou, lorenz, rossler]
    nombres = ["Zhou", "Lorenz", "Rossler"]

    for i in range(3):

        if(nombres[i] == "Zhou"):
            Y = np.array([-1., 2., 15.]) # valores iniciales dados en paper
        else:
            Y = np.array([1., 1., 1.]) # valores iniciales dados en paper

        t = 0 # tiempo 0
        h = .01 # es el incremento en cada paso de tiempo
        # tendremos vectores que contienen el tiempo y el recorrido en espacio
        T, x, y, z = rugen_kutta4(t, Y, h, funciones[i])
        plot_atractor_3d(nombres[i], x, y, z)
        plot_atractor_2d(nombres[i], 'X', 'Y', x, y)
        plot_atractor_2d(nombres[i], 'X', 'Z', x, z)
        plot_atractor_2d(nombres[i], 'Y', 'Z', y, z)

if __name__ == "__main__":
    run()

